/***********************************************************************
*
* Copyright (c) 2012-2019 Barbara Geller
* Copyright (c) 2012-2019 Ansel Sermersheim
*
* Copyright (C) 2015 The Qt Company Ltd.
* Copyright (c) 2012-2016 Digia Plc and/or its subsidiary(-ies).
* Copyright (c) 2008-2012 Nokia Corporation and/or its subsidiary(-ies).
*
* This file is part of CopperSpice.
*
* CopperSpice is free software. You can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public License
* version 2.1 as published by the Free Software Foundation.
*
* CopperSpice is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
* https://www.gnu.org/licenses/
*
***********************************************************************/

#define Q_SCRIPT_REGEXPLITERAL_RULE1 7
#define Q_SCRIPT_REGEXPLITERAL_RULE2 8

#include <translator.h>

#include <QtCore/QCoreApplication>
#include <QtCore/qdebug.h>
#include <QtCore/qnumeric.h>
#include <QtCore/qstring.h>
#include <QtCore/qtextcodec.h>
#include <QtCore/qvariant.h>

#include <iostream>

#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

QT_BEGIN_NAMESPACE

class LU
{
   Q_DECLARE_TR_FUNCTIONS(LUpdate)
};

static QString16 MagicComment("TRANSLATOR");

class QScriptGrammar
{
 public:
   enum {
      EOF_SYMBOL = 0,
      T_AND = 1,
      T_AND_AND = 2,
      T_AND_EQ = 3,
      T_AUTOMATIC_SEMICOLON = 62,
      T_BREAK = 4,
      T_CASE = 5,
      T_CATCH = 6,
      T_COLON = 7,
      T_COMMA = 8,
      T_CONST = 81,
      T_CONTINUE = 9,
      T_DEBUGGER = 82,
      T_DEFAULT = 10,
      T_DELETE = 11,
      T_DIVIDE_ = 12,
      T_DIVIDE_EQ = 13,
      T_DO = 14,
      T_DOT = 15,
      T_ELSE = 16,
      T_EQ = 17,
      T_EQ_EQ = 18,
      T_EQ_EQ_EQ = 19,
      T_FALSE = 80,
      T_FINALLY = 20,
      T_FOR = 21,
      T_FUNCTION = 22,
      T_GE = 23,
      T_GT = 24,
      T_GT_GT = 25,
      T_GT_GT_EQ = 26,
      T_GT_GT_GT = 27,
      T_GT_GT_GT_EQ = 28,
      T_IDENTIFIER = 29,
      T_IF = 30,
      T_IN = 31,
      T_INSTANCEOF = 32,
      T_LBRACE = 33,
      T_LBRACKET = 34,
      T_LE = 35,
      T_LPAREN = 36,
      T_LT = 37,
      T_LT_LT = 38,
      T_LT_LT_EQ = 39,
      T_MINUS = 40,
      T_MINUS_EQ = 41,
      T_MINUS_MINUS = 42,
      T_NEW = 43,
      T_NOT = 44,
      T_NOT_EQ = 45,
      T_NOT_EQ_EQ = 46,
      T_NULL = 78,
      T_NUMERIC_LITERAL = 47,
      T_OR = 48,
      T_OR_EQ = 49,
      T_OR_OR = 50,
      T_PLUS = 51,
      T_PLUS_EQ = 52,
      T_PLUS_PLUS = 53,
      T_QUESTION = 54,
      T_RBRACE = 55,
      T_RBRACKET = 56,
      T_REMAINDER = 57,
      T_REMAINDER_EQ = 58,
      T_RESERVED_WORD = 83,
      T_RETURN = 59,
      T_RPAREN = 60,
      T_SEMICOLON = 61,
      T_STAR = 63,
      T_STAR_EQ = 64,
      T_STRING_LITERAL = 65,
      T_SWITCH = 66,
      T_THIS = 67,
      T_THROW = 68,
      T_TILDE = 69,
      T_TRUE = 79,
      T_TRY = 70,
      T_TYPEOF = 71,
      T_VAR = 72,
      T_VOID = 73,
      T_WHILE = 74,
      T_WITH = 75,
      T_XOR = 76,
      T_XOR_EQ = 77,

      ACCEPT_STATE = 236,
      RULE_COUNT = 267,
      STATE_COUNT = 465,
      TERMINAL_COUNT = 84,
      NON_TERMINAL_COUNT = 88,

      GOTO_INDEX_OFFSET = 465,
      GOTO_INFO_OFFSET = 1374,
      GOTO_CHECK_OFFSET = 1374
   };

   static const char  *const spell [];
   static const int            lhs [];
   static const int            rhs [];
   static const int   goto_default [];
   static const int action_default [];
   static const int   action_index [];
   static const int    action_info [];
   static const int   action_check [];

   static inline int nt_action (int state, int nt) {
      const int *const goto_index = &action_index [GOTO_INDEX_OFFSET];
      const int *const goto_check = &action_check [GOTO_CHECK_OFFSET];

      const int yyn = goto_index [state] + nt;

      if (yyn < 0 || goto_check [yyn] != nt) {
         return goto_default [nt];
      }

      const int *const goto_info = &action_info [GOTO_INFO_OFFSET];
      return goto_info [yyn];
   }

   static inline int t_action (int state, int token) {
      const int yyn = action_index [state] + token;

      if (yyn < 0 || action_check [yyn] != token) {
         return - action_default [state];
      }

      return action_info [yyn];
   }
};

const char *const QScriptGrammar::spell [] = {
   "end of file", "&", "&&", "&=", "break", "case", "catch", ":", ";", "continue",
   "default", "delete", "/", "/=", "do", ".", "else", "=", "==", "===",
   "finally", "for", "function", ">=", ">", ">>", ">>=", ">>>", ">>>=", "identifier",
   "if", "in", "instanceof", "{", "[", "<=", "(", "<", "<<", "<<=",
   "-", "-=", "--", "new", "!", "!=", "!==", "numeric literal", "|", "|=",
   "||", "+", "+=", "++", "?", "}", "]", "%", "%=", "return",
   ")", ";", 0, "*", "*=", "string literal", "switch", "this", "throw", "~",
   "try", "typeof", "var", "void", "while", "with", "^", "^=", "null", "true",
   "false", "const", "debugger", "reserved word"
};

const int QScriptGrammar::lhs [] = {
   85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
   85, 85, 85, 85, 87, 87, 91, 91, 86, 86,
   92, 92, 93, 93, 93, 93, 94, 94, 94, 94,
   94, 94, 94, 94, 94, 94, 94, 94, 94, 94,
   94, 94, 94, 94, 94, 94, 94, 94, 94, 94,
   94, 94, 94, 94, 94, 94, 94, 95, 95, 96,
   96, 96, 96, 96, 99, 99, 100, 100, 100, 100,
   98, 98, 101, 101, 102, 102, 103, 103, 103, 104,
   104, 104, 104, 104, 104, 104, 104, 104, 104, 105,
   105, 105, 105, 106, 106, 106, 107, 107, 107, 107,
   108, 108, 108, 108, 108, 108, 108, 109, 109, 109,
   109, 109, 109, 110, 110, 110, 110, 110, 111, 111,
   111, 111, 111, 112, 112, 113, 113, 114, 114, 115,
   115, 116, 116, 117, 117, 118, 118, 119, 119, 120,
   120, 121, 121, 122, 122, 123, 123, 90, 90, 124,
   124, 125, 125, 125, 125, 125, 125, 125, 125, 125,
   125, 125, 125, 89, 89, 126, 126, 127, 127, 128,
   128, 129, 129, 129, 129, 129, 129, 129, 129, 129,
   129, 129, 129, 129, 129, 129, 130, 146, 146, 145,
   145, 131, 131, 147, 147, 148, 148, 150, 150, 149,
   151, 154, 152, 152, 155, 153, 153, 132, 133, 133,
   134, 134, 135, 135, 135, 135, 135, 135, 135, 136,
   136, 136, 136, 137, 137, 137, 137, 138, 138, 139,
   141, 156, 156, 159, 159, 157, 157, 160, 158, 140,
   142, 142, 143, 143, 143, 161, 162, 144, 163, 97,
   167, 167, 164, 164, 165, 165, 168, 84, 169, 169,
   170, 170, 166, 166, 88, 88, 171
};

const int QScriptGrammar:: rhs[] = {
   1, 1, 1, 1, 1, 1, 1, 1, 1, 3,
   3, 5, 3, 3, 2, 4, 1, 2, 0, 1,
   3, 5, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 4, 3, 3, 1, 2, 2, 2, 4, 3,
   2, 3, 1, 3, 1, 1, 1, 2, 2, 1,
   2, 2, 2, 2, 2, 2, 2, 2, 2, 1,
   3, 3, 3, 1, 3, 3, 1, 3, 3, 3,
   1, 3, 3, 3, 3, 3, 3, 1, 3, 3,
   3, 3, 3, 1, 3, 3, 3, 3, 1, 3,
   3, 3, 3, 1, 3, 1, 3, 1, 3, 1,
   3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
   3, 1, 3, 1, 5, 1, 5, 1, 3, 1,
   3, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 3, 0, 1, 1, 3, 0,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 3, 1, 2, 0,
   1, 3, 3, 1, 1, 1, 3, 1, 3, 2,
   2, 2, 0, 1, 2, 0, 1, 1, 2, 2,
   7, 5, 7, 7, 5, 9, 10, 7, 8, 2,
   2, 3, 3, 2, 2, 3, 3, 3, 3, 5,
   5, 3, 5, 1, 2, 0, 1, 4, 3, 3,
   3, 3, 3, 3, 4, 5, 2, 1, 8, 8,
   1, 3, 0, 1, 0, 1, 1, 1, 1, 2,
   1, 1, 0, 1, 0, 1, 2
};

const int QScriptGrammar::action_default [] = {
   0, 97, 164, 128, 136, 132, 172, 179, 76, 148,
   178, 186, 174, 124, 0, 175, 262, 61, 176, 177,
   182, 77, 140, 144, 65, 94, 75, 80, 60, 0,
   114, 180, 101, 259, 258, 261, 183, 0, 194, 0,
   248, 0, 8, 9, 0, 5, 0, 263, 2, 0,
   265, 19, 0, 0, 0, 0, 0, 3, 6, 0,
   0, 166, 208, 7, 0, 1, 0, 0, 4, 0,
   0, 195, 0, 0, 0, 184, 185, 90, 0, 173,
   181, 0, 0, 77, 96, 263, 2, 265, 79, 78,
   0, 0, 0, 92, 93, 91, 0, 264, 253, 254,
   0, 251, 0, 252, 0, 255, 256, 0, 257, 250,
   260, 0, 266, 0, 26, 27, 28, 29, 30, 31,
   32, 33, 34, 35, 36, 37, 38, 39, 40, 23,
   41, 42, 43, 44, 45, 25, 46, 47, 24, 48,
   49, 50, 51, 52, 53, 54, 55, 56, 57, 0,
   21, 0, 0, 0, 22, 13, 95, 0, 125, 0,
   0, 0, 0, 115, 0, 0, 0, 0, 0, 0,
   105, 0, 0, 0, 99, 100, 98, 103, 107, 106,
   104, 102, 117, 116, 118, 0, 133, 0, 129, 68,
   0, 0, 0, 70, 59, 58, 0, 0, 69, 165,
   0, 73, 71, 0, 72, 74, 209, 210, 0, 161,
   154, 152, 159, 160, 158, 157, 163, 156, 155, 153,
   162, 149, 0, 137, 0, 0, 141, 0, 0, 145,
   67, 0, 0, 63, 0, 62, 267, 224, 0, 225,
   226, 227, 220, 0, 221, 222, 223, 81, 0, 0,
   0, 0, 0, 213, 214, 170, 168, 130, 138, 134,
   150, 126, 171, 0, 77, 142, 146, 119, 108, 0,
   0, 127, 0, 0, 0, 0, 120, 0, 0, 0,
   0, 0, 112, 110, 113, 111, 109, 122, 121, 123,
   0, 135, 0, 131, 0, 169, 77, 0, 151, 166,
   167, 0, 166, 0, 0, 216, 0, 0, 0, 218,
   0, 139, 0, 0, 143, 0, 0, 147, 206, 0,
   198, 207, 201, 0, 205, 0, 166, 199, 0, 166,
   0, 0, 217, 0, 0, 0, 219, 264, 253, 0,
   0, 255, 0, 249, 0, 240, 0, 0, 0, 212,
   0, 211, 188, 191, 0, 27, 30, 31, 248, 34,
   35, 5, 39, 40, 2, 41, 44, 3, 6, 166,
   7, 48, 1, 50, 4, 52, 53, 54, 55, 56,
   57, 189, 187, 65, 66, 64, 0, 228, 229, 0,
   0, 0, 231, 236, 234, 237, 0, 0, 235, 236,
   0, 232, 0, 233, 190, 239, 0, 190, 238, 0,
   241, 242, 0, 190, 243, 244, 0, 0, 245, 0,
   0, 0, 246, 247, 83, 82, 0, 0, 0, 215,
   0, 0, 0, 230, 0, 20, 0, 17, 19, 11,
   0, 16, 12, 18, 15, 10, 0, 14, 87, 85,
   89, 86, 84, 88, 203, 196, 0, 204, 200, 0,
   202, 192, 0, 193, 197
};

const int QScriptGrammar::goto_default [] = {
   29, 28, 436, 434, 113, 14, 2, 435, 112, 111,
   114, 193, 24, 17, 189, 26, 8, 200, 21, 27,
   77, 25, 1, 32, 30, 267, 13, 261, 3, 257,
   5, 259, 4, 258, 22, 265, 23, 266, 9, 260,
   256, 297, 386, 262, 263, 35, 6, 79, 12, 15,
   18, 19, 10, 7, 31, 80, 20, 36, 75, 76,
   11, 354, 353, 78, 456, 455, 319, 320, 458, 322,
   457, 321, 392, 396, 399, 395, 394, 414, 415, 16,
   100, 107, 96, 99, 106, 108, 33, 0
};

const int QScriptGrammar::action_index [] = {
   1210, 59, -84, 71, 41, -1, -84, -84, 148, -84,
   -84, -84, -84, 201, 130, -84, -84, -84, -84, -84,
   -84, 343, 67, 62, 122, 109, -84, -84, -84, 85,
   273, -84, 184, -84, 1210, -84, -84, 119, -84, 112,
   -84, 521, -84, -84, 1130, -84, 45, 54, 58, 38,
   1290, 50, 521, 521, 521, 376, 521, -84, -84, 521,
   521, 521, -84, -84, 25, -84, 521, 521, -84, 43,
   521, -84, 521, 18, 15, -84, -84, -84, 24, -84,
   -84, 521, 521, 64, 153, 27, -84, 1050, -84, -84,
   521, 521, 521, -84, -84, -84, 28, -84, 37, 55,
   19, -84, 33, -84, 34, 1210, -84, 16, 1210, -84,
   -84, 39, 52, -3, -84, -84, -84, -84, -84, -84,
   -84, -84, -84, -84, -84, -84, -84, -84, -84, -84,
   -84, -84, -84, -84, -84, -84, -84, -84, -84, -84,
   -84, -84, -84, -84, -84, -84, -84, -84, -84, 521,
   -84, 1050, 125, 521, -84, -84, 155, 521, 189, 521,
   521, 521, 521, 248, 521, 521, 521, 521, 521, 521,
   243, 521, 521, 521, 75, 82, 94, 177, 184, 184,
   184, 184, 263, 283, 298, 521, 44, 521, 77, -84,
   970, 521, 817, -84, -84, -84, 95, 521, -84, -84,
   93, -84, -84, 521, -84, -84, -84, -84, 521, -84,
   -84, -84, -84, -84, -84, -84, -84, -84, -84, -84,
   -84, -84, 521, 41, 521, 521, 68, 66, 521, -84,
   -84, 970, 521, -84, 103, -84, -84, -84, 63, -84,
   -84, -84, -84, 69, -84, -84, -84, -84, -27, 12,
   521, 92, 100, -84, -84, 890, -84, 31, -13, -45,
   -84, 210, 32, -28, 387, 20, 73, 304, 117, -5,
   521, 212, 521, 521, 521, 521, 213, 521, 521, 521,
   521, 521, 151, 150, 176, 158, 168, 304, 304, 228,
   521, -72, 521, 4, 521, -84, 306, 521, -84, 521,
   8, -50, 521, -48, 1130, -84, 521, 80, 1130, -84,
   521, -33, 521, 521, 5, 48, 521, -84, 17, 88,
   11, -84, -84, 521, -84, -29, 521, -84, -41, 521,
   -39, 1130, -84, 521, 87, 1130, -84, -8, -2, -35,
   10, 1210, -16, -84, 1130, -84, 521, 86, 1130, -14,
   1130, -84, -84, 1130, -36, 107, -21, 165, 3, 521,
   1130, 6, 14, 61, 7, -19, 448, -4, -6, 671,
   29, 13, 23, 521, 30, -10, 521, 9, 521, -30,
   -18, -84, -84, 164, -84, -84, 46, -84, -84, 521,
   111, -24, -84, 36, -84, 40, 99, 521, -84, 21,
   22, -84, -11, -84, 1130, -84, 106, 1130, -84, 178,
   -84, -84, 98, 1130, 57, -84, 56, 60, -84, 51,
   26, 35, -84, -84, -84, -84, 521, 97, 1130, -84,
   521, 90, 1130, -84, 79, 76, 744, -84, 49, -84,
   594, -84, -84, -84, -84, -84, 83, -84, -84, -84,
   -84, -84, -84, -84, 42, -84, 162, -84, -84, 521,
   -84, -84, 53, -84, -84,

   -61, -88, -88, -88, -88, -88, -88, -88, -88, -88,
   -88, -88, -88, -88, -88, -88, -88, -88, -88, -88,
   -88, -4, -88, -88, 22, -88, -88, -88, -88, -88,
   -88, -88, -88, -88, -51, -88, -88, -88, -88, -88,
   -88, 105, -88, -88, -12, -88, -88, -88, -88, -88,
   -7, -88, 35, 132, 62, 154, 79, -88, -88, 100,
   75, 36, -88, -88, -88, -88, 37, 70, -88, -1,
   86, -88, 92, -88, -88, -88, -88, -88, -88, -88,
   -88, 90, 95, -88, -88, -88, -88, -88, -88, -88,
   87, 82, 74, -88, -88, -88, -88, -88, -88, -88,
   -88, -88, -88, -88, -88, -88, -88, -88, -47, -88,
   -88, -88, -88, -88, -88, -88, -88, -88, -88, -88,
   -88, -88, -88, -88, -88, -88, -88, -88, -88, -88,
   -88, -88, -88, -88, -88, -88, -88, -88, -88, -88,
   -88, -88, -88, -88, -88, -88, -88, -88, -88, 28,
   -88, 20, -88, 19, -88, -88, -88, 39, -88, 42,
   43, 106, 61, -88, 63, 55, 52, 53, 91, 125,
   -88, 120, 123, 118, -88, -88, -88, -88, -88, -88,
   -88, -88, -88, -88, -88, 116, -88, 59, -88, -88,
   16, 18, 15, -88, -88, -88, -88, 21, -88, -88,
   -88, -88, -88, 24, -88, -88, -88, -88, 38, -88,
   -88, -88, -88, -88, -88, -88, -88, -88, -88, -88,
   -88, -88, 97, -88, 115, 25, -88, -88, 26, -88,
   -88, 111, 14, -88, -88, -88, -88, -88, -88, -88,
   -88, -88, -88, -88, -88, -88, -88, -88, -88, -88,
   23, -88, -88, -88, -88, 108, -88, -88, -88, -88,
   -88, -88, -88, -88, -88, -88, -88, -88, -88, -88,
   160, -88, 171, 163, 145, 179, -88, 135, 45, 41,
   66, 80, -88, -88, -88, -88, -88, -88, -88, -88,
   172, -88, 156, -88, 142, -88, -88, 144, -88, 122,
   -88, -88, 114, -88, -23, -88, 48, -88, 29, -88,
   224, -88, 157, 175, -88, -88, 182, -88, -88, -88,
   -88, -88, -88, 183, -88, -21, 134, -88, -88, 49,
   -88, 3, -88, 44, -88, 2, -88, -88, -37, -88,
   -88, -31, -88, -88, 10, -88, 47, -88, 17, -88,
   27, -88, -88, 13, -88, -88, -88, -88, -88, 117,
   6, -88, -88, -88, -88, -88, 154, -88, -88, 1,
   -88, -88, -88, 7, -88, -35, 137, -88, 141, -88,
   -88, -88, -88, -6, -88, -88, -88, -88, -88, 78,
   -88, -88, -88, -88, -88, -69, -88, 11, -88, -59,
   -88, -88, -88, -88, 83, -88, -88, 56, -88, -88,
   -88, -88, -88, -40, -58, -88, -88, -29, -88, -88,
   -88, -45, -88, -88, -88, -88, -3, -88, -42, -88,
   -5, -88, -32, -88, -88, -88, 9, -88, 8, -88,
   -2, -88, -88, -88, -88, -88, -88, -88, -88, -88,
   -88, -88, -88, -88, -88, -88, -88, -88, -88, 12,
   -88, -88, -56, -88, -88
};

const int QScriptGrammar::action_info [] = {
   318, -25, 350, -45, 292, 270, 426, 310, -194, 393,
   -32, 302, 304, -37, 344, 290, 197, 346, 430, 382,
   329, 331, 310, 413, 318, 340, 397, 101, 338, 404,
   -49, 292, 270, 299, 323, 290, -24, -51, -195, 343,
   294, 397, 333, 341, 403, 397, 149, 249, 250, 389,
   255, 430, 155, 454, 426, 316, 97, 437, 437, 459,
   151, 389, 103, 102, 98, 344, 101, 105, 413, 222,
   222, 109, 157, 228, 346, 187, 413, 417, 157, 104,
   420, 255, 454, 337, 443, 236, 421, 438, 197, 185,
   97, 197, 419, 413, 197, 197, 325, -263, 197, 81,
   197, 203, 0, 197, 416, 197, 88, 388, 387, 400,
   82, 197, 224, 407, 197, 81, 225, 89, 417, 197,
   187, 90, 81, 312, 241, 240, 82, 313, 0, 0,
   246, 245, 153, 82, 81, 439, 238, 231, 197, 0,
   308, 243, 171, 447, 172, 82, 348, 335, 238, 326,
   432, 198, 252, 204, 401, 173, 232, 428, 192, 235,
   0, 254, 253, 190, 0, 90, 91, 90, 239, 237,
   462, 391, 92, 244, 242, 171, 171, 172, 172, 231,
   239, 237, 191, 171, 192, 172, 197, 0, 173, 173,
   0, 207, 206, 171, 243, 172, 173, 0, 232, 0,
   192, 171, 171, 172, 172, 0, 173, 159, 160, 171,
   91, 172, 91, 0, 173, 173, 92, 0, 92, 159,
   160, 0, 173, 463, 461, 0, 244, 242, 272, 273,
   272, 273, 0, 0, 161, 162, 277, 278, 0, 411,
   410, 0, 0, 0, 0, 279, 161, 162, 280, 0,
   281, 277, 278, 0, 0, 274, 275, 274, 275, 0,
   279, 0, 0, 280, 0, 281, 0, 0, 171, 0,
   172, 164, 165, 0, 0, 0, 0, 0, 0, 166,
   167, 173, 0, 168, 0, 169, 164, 165, 0, 0,
   0, 0, 0, 0, 166, 167, 164, 165, 168, 0,
   169, 0, 0, 0, 166, 167, 164, 165, 168, 209,
   169, 0, 0, 0, 166, 167, 0, 0, 168, 210,
   169, 164, 165, 211, 0, 0, 0, 277, 278, 166,
   167, 0, 212, 168, 213, 169, 279, 0, 0, 280,
   0, 281, 0, 0, 0, 214, 209, 215, 88, 0,
   0, 0, 0, 0, 0, 216, 210, 0, 217, 89,
   211, 0, 0, 0, 218, 0, 0, 0, 0, 212,
   219, 213, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 214, 220, 215, 88, 0, 0, 42, 43,
   209, 0, 216, 0, 0, 217, 89, 0, 85, 0,
   210, 218, 0, 0, 211, 86, 0, 219, 0, 87,
   51, 0, 52, 212, 0, 213, 0, 0, 306, 55,
   220, 0, 0, 58, 0, 0, 214, 0, 215, 88,
   0, 0, 0, 0, 0, 0, 216, 0, 0, 217,
   89, 63, 0, 65, 0, 218, 0, 0, 0, 0,
   0, 219, 0, 0, 57, 68, 45, 0, 0, 0,
   42, 43, 0, 0, 220, 0, 0, 0, 0, 0,
   85, 0, 0, 0, 0, 0, 0, 86, 0, 0,
   0, 87, 51, 0, 52, 0, 0, 0, 0, 0,
   0, 55, 0, 0, 0, 58, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 63, 0, 65, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 57, 68, 45, 0,
   0, 0, 41, 42, 43, 0, 0, 0, 0, 0,
   0, 0, 0, 85, 0, 0, 0, 0, 0, 0,
   86, 0, 0, 0, 87, 51, 0, 52, 0, 0,
   0, 53, 0, 54, 55, 56, 0, 0, 58, 0,
   0, 0, 59, 0, 60, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 63, 0, 65, 0,
   67, 0, 70, 0, 72, 0, 0, 0, 0, 57,
   68, 45, 0, 0, 0, 41, 42, 43, 0, 0,
   0, 0, 0, 0, 0, 0, 85, 0, 0, 0,
   0, 0, 0, 86, 0, 0, 0, 87, 51, 0,
   52, 0, 0, 0, 53, 0, 54, 55, 56, 0,
   0, 58, 0, 0, 0, 59, 0, 60, 0, 0,
   442, 0, 0, 0, 0, 0, 0, 0, 0, 63,
   0, 65, 0, 67, 0, 70, 0, 72, 0, 0,
   0, 0, 57, 68, 45, 0, 0, 0, -47, 0,
   0, 0, 41, 42, 43, 0, 0, 0, 0, 0,
   0, 0, 0, 85, 0, 0, 0, 0, 0, 0,
   86, 0, 0, 0, 87, 51, 0, 52, 0, 0,
   0, 53, 0, 54, 55, 56, 0, 0, 58, 0,
   0, 0, 59, 0, 60, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 63, 0, 65, 0,
   67, 0, 70, 0, 72, 0, 0, 0, 0, 57,
   68, 45, 0, 0, 0, 41, 42, 43, 0, 0,
   0, 0, 0, 0, 0, 0, 85, 0, 0, 0,
   0, 0, 0, 86, 0, 0, 0, 87, 51, 0,
   52, 0, 0, 0, 53, 0, 54, 55, 56, 0,
   0, 58, 0, 0, 0, 59, 0, 60, 0, 0,
   445, 0, 0, 0, 0, 0, 0, 0, 0, 63,
   0, 65, 0, 67, 0, 70, 0, 72, 0, 0,
   0, 0, 57, 68, 45, 0, 0, 0, 41, 42,
   43, 0, 0, 0, 0, 0, 0, 0, 0, 85,
   0, 0, 0, 0, 0, 0, 86, 0, 0, 0,
   87, 51, 0, 52, 0, 0, 0, 53, 0, 54,
   55, 56, 0, 0, 58, 0, 0, 0, 59, 0,
   60, 0, 0, 0, 0, 0, 0, 202, 0, 0,
   0, 0, 63, 0, 65, 0, 67, 0, 70, 0,
   72, 0, 0, 0, 0, 57, 68, 45, 0, 0,
   0, 41, 42, 43, 0, 0, 0, 0, 0, 0,
   0, 0, 85, 0, 0, 0, 0, 0, 0, 86,
   0, 0, 0, 87, 51, 0, 52, 0, 0, 0,
   53, 0, 54, 55, 56, 0, 0, 58, 0, 0,
   0, 59, 0, 60, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 63, 0, 65, 0, 67,
   0, 70, 269, 72, 0, 0, 0, 0, 57, 68,
   45, 0, 0, 0, 115, 116, 117, 0, 0, 119,
   121, 122, 0, 0, 123, 0, 124, 0, 0, 0,
   126, 127, 128, 0, 0, 0, 0, 0, 0, 195,
   130, 131, 132, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 133, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 137,
   0, 0, 0, 0, 0, 0, 139, 140, 141, 0,
   143, 144, 145, 146, 147, 148, 0, 0, 134, 142,
   125, 118, 120, 136, 115, 116, 117, 0, 0, 119,
   121, 122, 0, 0, 123, 0, 124, 0, 0, 0,
   126, 127, 128, 0, 0, 0, 0, 0, 0, 129,
   130, 131, 132, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 133, 0, 0, 0, 135, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 137,
   0, 0, 0, 0, 0, 138, 139, 140, 141, 0,
   143, 144, 145, 146, 147, 148, 0, 0, 134, 142,
   125, 118, 120, 136, 37, 0, 0, 0, 0, 39,
   0, 41, 42, 43, 44, 0, 0, 0, 0, 0,
   0, 46, 85, 0, 0, 0, 0, 0, 0, 48,
   49, 0, 0, 50, 51, 0, 52, 0, 0, 0,
   53, 0, 54, 55, 56, 0, 0, 58, 0, 0,
   0, 59, 0, 60, 0, 0, 0, 0, 0, 61,
   0, 62, 0, 0, 0, 63, 64, 65, 66, 67,
   69, 70, 71, 72, 73, 74, 0, 0, 57, 68,
   45, 38, 40, 0, 37, 0, 0, 0, 0, 39,
   0, 41, 42, 43, 44, 0, 0, 0, 0, 0,
   0, 46, 47, 0, 0, 0, 0, 0, 0, 48,
   49, 0, 0, 50, 51, 0, 52, 0, 0, 0,
   53, 0, 54, 55, 56, 0, 0, 58, 0, 0,
   0, 59, 0, 60, 0, 0, 0, 0, 0, 61,
   0, 62, 0, 0, 0, 63, 64, 65, 66, 67,
   69, 70, 71, 72, 73, 74, 0, 0, 57, 68,
   45, 38, 40, 0, 355, 116, 117, 0, 0, 357,
   121, 359, 42, 43, 360, 0, 124, 0, 0, 0,
   126, 362, 363, 0, 0, 0, 0, 0, 0, 364,
   365, 131, 132, 50, 51, 0, 52, 0, 0, 0,
   53, 0, 54, 366, 56, 0, 0, 368, 0, 0,
   0, 59, 0, 60, 0, -190, 0, 0, 0, 369,
   0, 62, 0, 0, 0, 370, 371, 372, 373, 67,
   375, 376, 377, 378, 379, 380, 0, 0, 367, 374,
   361, 356, 358, 136,

   431, 422, 427, 429, 441, 352, 300, 398, 385, 464,
   440, 412, 409, 433, 402, 444, 406, 423, 460, 234,
   418, 201, 305, 196, 34, 154, 194, 199, 251, 152,
   205, 227, 229, 248, 150, 110, 230, 208, 352, 110,
   446, 300, 409, 339, 221, 412, 327, 336, 332, 334,
   342, 248, 347, 307, 300, 345, 0, 83, 381, 83,
   83, 83, 349, 83, 284, 158, 163, 182, 283, 0,
   83, 83, 351, 83, 309, 178, 179, 83, 177, 83,
   83, 83, 449, 390, 83, 184, 170, 188, 83, 285,
   453, 330, 83, 83, 95, 452, 0, 83, 83, 450,
   83, 352, 94, 286, 83, 83, 424, 93, 83, 83,
   83, 84, 425, 83, 180, 83, 156, 408, 83, 300,
   451, 194, 233, 83, 83, 247, 264, 300, 352, 223,
   183, 268, 0, 83, 83, 83, 83, 247, 83, 300,
   176, 83, 174, 83, 405, 175, 186, 0, 181, 226,
   83, 0, 448, 83, 0, 83, 303, 424, 282, 83,
   296, 425, 296, 83, 301, 268, 383, 268, 268, 384,
   288, 0, 0, 0, 83, 83, 328, 0, 83, 268,
   268, 83, 295, 268, 298, 293, 268, 271, 287, 83,
   83, 0, 314, 296, 268, 268, 276, 83, 268, 0,
   296, 296, 268, 291, 289, 268, 268, 0, 0, 0,
   0, 0, 0, 0, 0, 315, 0, 0, 0, 0,
   0, 0, 317, 324, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 83, 0, 0, 0, 0, 268, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 311, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0
};

const int QScriptGrammar::action_check [] = {
   29, 7, 16, 7, 76, 1, 36, 2, 29, 33,
   7, 61, 60, 7, 7, 48, 8, 36, 36, 55,
   61, 60, 2, 33, 29, 60, 5, 29, 36, 7,
   7, 76, 1, 61, 17, 48, 7, 7, 29, 55,
   8, 5, 31, 33, 55, 5, 7, 74, 36, 36,
   36, 36, 55, 29, 36, 7, 29, 8, 8, 17,
   8, 36, 29, 8, 36, 7, 29, 33, 33, 2,
   2, 55, 1, 7, 36, 76, 33, 20, 1, 60,
   29, 36, 29, 29, 8, 0, 60, 8, 8, 48,
   29, 8, 36, 33, 8, 8, 8, 36, 8, 40,
   8, 8, -1, 8, 6, 8, 42, 61, 62, 10,
   51, 8, 50, 7, 8, 40, 54, 53, 20, 8,
   76, 12, 40, 50, 61, 62, 51, 54, -1, -1,
   61, 62, 7, 51, 40, 56, 29, 15, 8, -1,
   60, 29, 25, 60, 27, 51, 60, 60, 29, 61,
   60, 56, 60, 60, 55, 38, 34, 60, 36, 56,
   -1, 61, 62, 15, -1, 12, 57, 12, 61, 62,
   8, 60, 63, 61, 62, 25, 25, 27, 27, 15,
   61, 62, 34, 25, 36, 27, 8, -1, 38, 38,
   -1, 61, 62, 25, 29, 27, 38, -1, 34, -1,
   36, 25, 25, 27, 27, -1, 38, 18, 19, 25,
   57, 27, 57, -1, 38, 38, 63, -1, 63, 18,
   19, -1, 38, 61, 62, -1, 61, 62, 18, 19,
   18, 19, -1, -1, 45, 46, 23, 24, -1, 61,
   62, -1, -1, -1, -1, 32, 45, 46, 35, -1,
   37, 23, 24, -1, -1, 45, 46, 45, 46, -1,
   32, -1, -1, 35, -1, 37, -1, -1, 25, -1,
   27, 23, 24, -1, -1, -1, -1, -1, -1, 31,
   32, 38, -1, 35, -1, 37, 23, 24, -1, -1,
   -1, -1, -1, -1, 31, 32, 23, 24, 35, -1,
   37, -1, -1, -1, 31, 32, 23, 24, 35, 3,
   37, -1, -1, -1, 31, 32, -1, -1, 35, 13,
   37, 23, 24, 17, -1, -1, -1, 23, 24, 31,
   32, -1, 26, 35, 28, 37, 32, -1, -1, 35,
   -1, 37, -1, -1, -1, 39, 3, 41, 42, -1,
   -1, -1, -1, -1, -1, 49, 13, -1, 52, 53,
   17, -1, -1, -1, 58, -1, -1, -1, -1, 26,
   64, 28, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, 39, 77, 41, 42, -1, -1, 12, 13,
   3, -1, 49, -1, -1, 52, 53, -1, 22, -1,
   13, 58, -1, -1, 17, 29, -1, 64, -1, 33,
   34, -1, 36, 26, -1, 28, -1, -1, 31, 43,
   77, -1, -1, 47, -1, -1, 39, -1, 41, 42,
   -1, -1, -1, -1, -1, -1, 49, -1, -1, 52,
   53, 65, -1, 67, -1, 58, -1, -1, -1, -1,
   -1, 64, -1, -1, 78, 79, 80, -1, -1, -1,
   12, 13, -1, -1, 77, -1, -1, -1, -1, -1,
   22, -1, -1, -1, -1, -1, -1, 29, -1, -1,
   -1, 33, 34, -1, 36, -1, -1, -1, -1, -1,
   -1, 43, -1, -1, -1, 47, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, 65, -1, 67, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, 78, 79, 80, -1,
   -1, -1, 11, 12, 13, -1, -1, -1, -1, -1,
   -1, -1, -1, 22, -1, -1, -1, -1, -1, -1,
   29, -1, -1, -1, 33, 34, -1, 36, -1, -1,
   -1, 40, -1, 42, 43, 44, -1, -1, 47, -1,
   -1, -1, 51, -1, 53, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, 65, -1, 67, -1,
   69, -1, 71, -1, 73, -1, -1, -1, -1, 78,
   79, 80, -1, -1, -1, 11, 12, 13, -1, -1,
   -1, -1, -1, -1, -1, -1, 22, -1, -1, -1,
   -1, -1, -1, 29, -1, -1, -1, 33, 34, -1,
   36, -1, -1, -1, 40, -1, 42, 43, 44, -1,
   -1, 47, -1, -1, -1, 51, -1, 53, -1, -1,
   56, -1, -1, -1, -1, -1, -1, -1, -1, 65,
   -1, 67, -1, 69, -1, 71, -1, 73, -1, -1,
   -1, -1, 78, 79, 80, -1, -1, -1, 7, -1,
   -1, -1, 11, 12, 13, -1, -1, -1, -1, -1,
   -1, -1, -1, 22, -1, -1, -1, -1, -1, -1,
   29, -1, -1, -1, 33, 34, -1, 36, -1, -1,
   -1, 40, -1, 42, 43, 44, -1, -1, 47, -1,
   -1, -1, 51, -1, 53, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, 65, -1, 67, -1,
   69, -1, 71, -1, 73, -1, -1, -1, -1, 78,
   79, 80, -1, -1, -1, 11, 12, 13, -1, -1,
   -1, -1, -1, -1, -1, -1, 22, -1, -1, -1,
   -1, -1, -1, 29, -1, -1, -1, 33, 34, -1,
   36, -1, -1, -1, 40, -1, 42, 43, 44, -1,
   -1, 47, -1, -1, -1, 51, -1, 53, -1, -1,
   56, -1, -1, -1, -1, -1, -1, -1, -1, 65,
   -1, 67, -1, 69, -1, 71, -1, 73, -1, -1,
   -1, -1, 78, 79, 80, -1, -1, -1, 11, 12,
   13, -1, -1, -1, -1, -1, -1, -1, -1, 22,
   -1, -1, -1, -1, -1, -1, 29, -1, -1, -1,
   33, 34, -1, 36, -1, -1, -1, 40, -1, 42,
   43, 44, -1, -1, 47, -1, -1, -1, 51, -1,
   53, -1, -1, -1, -1, -1, -1, 60, -1, -1,
   -1, -1, 65, -1, 67, -1, 69, -1, 71, -1,
   73, -1, -1, -1, -1, 78, 79, 80, -1, -1,
   -1, 11, 12, 13, -1, -1, -1, -1, -1, -1,
   -1, -1, 22, -1, -1, -1, -1, -1, -1, 29,
   -1, -1, -1, 33, 34, -1, 36, -1, -1, -1,
   40, -1, 42, 43, 44, -1, -1, 47, -1, -1,
   -1, 51, -1, 53, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, 65, -1, 67, -1, 69,
   -1, 71, 72, 73, -1, -1, -1, -1, 78, 79,
   80, -1, -1, -1, 4, 5, 6, -1, -1, 9,
   10, 11, -1, -1, 14, -1, 16, -1, -1, -1,
   20, 21, 22, -1, -1, -1, -1, -1, -1, 29,
   30, 31, 32, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, 43, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, 59,
   -1, -1, -1, -1, -1, -1, 66, 67, 68, -1,
   70, 71, 72, 73, 74, 75, -1, -1, 78, 79,
   80, 81, 82, 83, 4, 5, 6, -1, -1, 9,
   10, 11, -1, -1, 14, -1, 16, -1, -1, -1,
   20, 21, 22, -1, -1, -1, -1, -1, -1, 29,
   30, 31, 32, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, 43, -1, -1, -1, 47, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, 59,
   -1, -1, -1, -1, -1, 65, 66, 67, 68, -1,
   70, 71, 72, 73, 74, 75, -1, -1, 78, 79,
   80, 81, 82, 83, 4, -1, -1, -1, -1, 9,
   -1, 11, 12, 13, 14, -1, -1, -1, -1, -1,
   -1, 21, 22, -1, -1, -1, -1, -1, -1, 29,
   30, -1, -1, 33, 34, -1, 36, -1, -1, -1,
   40, -1, 42, 43, 44, -1, -1, 47, -1, -1,
   -1, 51, -1, 53, -1, -1, -1, -1, -1, 59,
   -1, 61, -1, -1, -1, 65, 66, 67, 68, 69,
   70, 71, 72, 73, 74, 75, -1, -1, 78, 79,
   80, 81, 82, -1, 4, -1, -1, -1, -1, 9,
   -1, 11, 12, 13, 14, -1, -1, -1, -1, -1,
   -1, 21, 22, -1, -1, -1, -1, -1, -1, 29,
   30, -1, -1, 33, 34, -1, 36, -1, -1, -1,
   40, -1, 42, 43, 44, -1, -1, 47, -1, -1,
   -1, 51, -1, 53, -1, -1, -1, -1, -1, 59,
   -1, 61, -1, -1, -1, 65, 66, 67, 68, 69,
   70, 71, 72, 73, 74, 75, -1, -1, 78, 79,
   80, 81, 82, -1, 4, 5, 6, -1, -1, 9,
   10, 11, 12, 13, 14, -1, 16, -1, -1, -1,
   20, 21, 22, -1, -1, -1, -1, -1, -1, 29,
   30, 31, 32, 33, 34, -1, 36, -1, -1, -1,
   40, -1, 42, 43, 44, -1, -1, 47, -1, -1,
   -1, 51, -1, 53, -1, 55, -1, -1, -1, 59,
   -1, 61, -1, -1, -1, 65, 66, 67, 68, 69,
   70, 71, 72, 73, 74, 75, -1, -1, 78, 79,
   80, 81, 82, 83,

   5, 46, 5, 45, 6, 45, 5, 76, 14, 65,
   2, 46, 5, 45, 73, 6, 5, 46, 6, 5,
   78, 6, 45, 5, 85, 6, 10, 6, 5, 9,
   6, 6, 6, 45, 6, 86, 14, 41, 45, 86,
   5, 5, 5, 80, 6, 46, 67, 45, 45, 5,
   81, 45, 5, 5, 5, 45, -1, 18, 45, 18,
   18, 18, 45, 18, 23, 26, 24, 24, 23, -1,
   18, 18, 45, 18, 45, 23, 23, 18, 23, 18,
   18, 18, 20, 5, 18, 24, 23, 28, 18, 23,
   20, 42, 18, 18, 20, 20, -1, 18, 18, 20,
   18, 45, 20, 23, 18, 18, 20, 20, 18, 18,
   18, 21, 20, 18, 23, 18, 21, 61, 18, 5,
   20, 10, 11, 18, 18, 20, 18, 5, 45, 32,
   24, 23, -1, 18, 18, 18, 18, 20, 18, 5,
   22, 18, 22, 18, 61, 22, 30, -1, 23, 34,
   18, -1, 20, 18, -1, 18, 42, 20, 23, 18,
   18, 20, 18, 18, 42, 23, 12, 23, 23, 15,
   25, -1, -1, -1, 18, 18, 42, -1, 18, 23,
   23, 18, 40, 23, 40, 29, 23, 27, 25, 18,
   18, -1, 35, 18, 23, 23, 25, 18, 23, -1,
   18, 18, 23, 31, 25, 23, 23, -1, -1, -1,
   -1, -1, -1, -1, -1, 40, -1, -1, -1, -1,
   -1, -1, 40, 40, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, 18, -1, -1, -1, -1, 23, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, 33, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1
};

static void recordMessage(
   Translator *tor, const QString &context, const QString &text, const QString &comment,
   const QString &extracomment, const QString &msgid, const TranslatorMessage::ExtraData &extra,
   bool plural, const QString &fileName, int lineNo)
{
   TranslatorMessage msg(
      context, text, comment, QString(),
      fileName, lineNo, QStringList(),
      TranslatorMessage::Unfinished, plural);
   msg.setExtraComment(extracomment.simplified());
   msg.setId(msgid);
   msg.setExtras(extra);
   tor->extend(msg);
}


namespace QScript {

class CommentProcessor
{
 public:
   virtual ~CommentProcessor() {}
   virtual void processComment(const QChar *chars, int length) = 0;
};

class Lexer
{
 public:
   Lexer(CommentProcessor *);
   ~Lexer();

   void setCode(const QString &c, const QString &fileName, int lineno);
   int lex();

   QString fileName() const {
      return yyfilename;
   }
   int currentLineNo() const {
      return yylineno;
   }
   int currentColumnNo() const {
      return yycolumn;
   }

   int startLineNo() const {
      return startlineno;
   }
   int startColumnNo() const {
      return startcolumn;
   }

   int endLineNo() const {
      return currentLineNo();
   }
   int endColumnNo() const {
      int col = currentColumnNo();
      return (col > 0) ? col - 1 : col;
   }

   bool prevTerminator() const {
      return terminator;
   }

   enum State { Start,
                Identifier,
                InIdentifier,
                InSingleLineComment,
                InMultiLineComment,
                InNum,
                InNum0,
                InHex,
                InOctal,
                InDecimal,
                InExponentIndicator,
                InExponent,
                Hex,
                Octal,
                Number,
                String,
                Eof,
                InString,
                InEscapeSequence,
                InHexEscape,
                InUnicodeEscape,
                Other,
                Bad
              };

   enum Error {
      NoError,
      IllegalCharacter,
      UnclosedStringLiteral,
      IllegalEscapeSequence,
      IllegalUnicodeEscapeSequence,
      UnclosedComment,
      IllegalExponentIndicator,
      IllegalIdentifier
   };

   enum ParenthesesState {
      IgnoreParentheses,
      CountParentheses,
      BalancedParentheses
   };

   enum RegExpBodyPrefix {
      NoPrefix,
      EqualPrefix
   };

   bool scanRegExp(RegExpBodyPrefix prefix = NoPrefix);

   QString pattern;
   int flags;

   State lexerState() const {
      return state;
   }

   QString errorMessage() const {
      return errmsg;
   }
   void setErrorMessage(const QString &err) {
      errmsg = err;
   }
   void setErrorMessage(const char *err) {
      setErrorMessage(QString::fromLatin1(err));
   }

   Error error() const {
      return err;
   }
   void clearError() {
      err = NoError;
   }

 private:
   QString yyfilename;
   int yylineno;
   bool done;
   char *buffer8;
   QChar *buffer16;
   uint size8, size16;
   uint pos8, pos16;
   bool terminator;
   bool restrKeyword;
   // encountered delimiter like "'" and "}" on last run
   bool delimited;
   int stackToken;

   State state;
   void setDone(State s);
   uint pos;
   void shift(uint p);
   int lookupKeyword(const char *);

   bool isWhiteSpace() const;
   bool isLineTerminator() const;
   bool isHexDigit(ushort c) const;
   bool isOctalDigit(ushort c) const;

   int matchPunctuator(ushort c1, ushort c2, ushort c3, ushort c4);
   ushort singleEscape(ushort c) const;
   ushort convertOctal(ushort c1, ushort c2,ushort c3) const;

 public:
   static unsigned char convertHex(ushort c1);
   static unsigned char convertHex(char32_t c1, char32_t c2);
   static QChar convertUnicode(char32_t c1, char32_t c2, char32_t c3, char32_t c4);
   static bool isIdentLetter(ushort c);
   static bool isDecimalDigit(ushort c);

   inline int ival() const {
      return qsyylval.toInt();
   }
   inline double dval() const {
      return qsyylval.toDouble();
   }
   inline QString ustr() const {
      return qsyylval.toString();
   }
   inline QVariant val() const {
      return qsyylval;
   }

   const QChar *characterBuffer() const {
      return buffer16;
   }
   int characterCount() const {
      return pos16;
   }

 private:
   void record8(ushort c);
   void record16(QChar c);
   void recordStartPos();

   int findReservedWord(const QChar *buffer, int size) const;

   void syncProhibitAutomaticSemicolon();

   void processComment(const QChar *, int);

   QString::const_iterator m_code;

   uint length;
   int yycolumn;
   int startlineno;
   int startcolumn;
   int bol;     // begin of line

   QVariant qsyylval;

   // current and following unicode characters
   ushort current, next1, next2, next3;

   struct keyword {
      const char *name;
      int token;
   };

   QString errmsg;
   Error err;

   bool wantRx;
   bool check_reserved;

   ParenthesesState parenthesesState;
   int parenthesesCount;
   bool prohibitAutomaticSemicolon;

   CommentProcessor *commentProcessor;
};

} // namespace QScript

extern double qstrtod(const char *s00, char const **se, bool *ok);

#define shiftWindowsLineBreak() if(current == '\r' && next1 == '\n') shift(1);

namespace QScript {

static int toDigit(char c)
{
   if ((c >= '0') && (c <= '9')) {
      return c - '0';
   } else if ((c >= 'a') && (c <= 'z')) {
      return 10 + c - 'a';
   } else if ((c >= 'A') && (c <= 'Z')) {
      return 10 + c - 'A';
   }
   return -1;
}

double integerFromString(const char *buf, int size, int radix)
{
   if (size == 0) {
      return qSNaN();
   }

   double sign = 1.0;
   int i = 0;
   if (buf[0] == '+') {
      ++i;
   } else if (buf[0] == '-') {
      sign = -1.0;
      ++i;
   }

   if (((size - i) >= 2) && (buf[i] == '0')) {
      if (((buf[i + 1] == 'x') || (buf[i + 1] == 'X'))
            && (radix < 34)) {
         if ((radix != 0) && (radix != 16)) {
            return 0;
         }
         radix = 16;
         i += 2;
      } else {
         if (radix == 0) {
            radix = 8;
            ++i;
         }
      }
   } else if (radix == 0) {
      radix = 10;
   }

   int j = i;
   for ( ; i < size; ++i) {
      int d = toDigit(buf[i]);
      if ((d == -1) || (d >= radix)) {
         break;
      }
   }
   double result;
   if (j == i) {
      if (!qstrcmp(buf, "Infinity")) {
         result = qInf();
      } else {
         result = qSNaN();
      }
   } else {
      result = 0;
      double multiplier = 1;
      for (--i ; i >= j; --i, multiplier *= radix) {
         result += toDigit(buf[i]) * multiplier;
      }
   }
   result *= sign;
   return result;
}

} // namespace QScript

QScript::Lexer::Lexer(QScript::CommentProcessor *proc)
   :
   yylineno(0),
   size8(128), size16(128), restrKeyword(false),
   stackToken(-1), pos(0), length(0),
   bol(true),
   current(0), next1(0), next2(0), next3(0),
   err(NoError),
   check_reserved(true),
   parenthesesState(IgnoreParentheses),
   prohibitAutomaticSemicolon(false),
   commentProcessor(proc)
{
   // allocate space for read buffers
   buffer8 = new char[size8];
   buffer16 = new QChar[size16];
   flags = 0;

}

QScript::Lexer::~Lexer()
{
   delete [] buffer8;
   delete [] buffer16;
}

void QScript::Lexer::setCode(const QString &c, const QString &fileName, int lineno)
{
   errmsg = QString();

   yyfilename = fileName;
   yylineno   = lineno;
   yycolumn   = 1;

   restrKeyword = false;
   delimited    = false;

   stackToken = -1;
   pos        = 0;
   m_code     = c.begin();
   length     = c.length();

   bol = true;

   // read first characters
   current = (length > 0) ? m_code[0].unicode() : 0;
   next1   = (length > 1) ? m_code[1].unicode() : 0;
   next2   = (length > 2) ? m_code[2].unicode() : 0;
   next3   = (length > 3) ? m_code[3].unicode() : 0;
}

void QScript::Lexer::shift(uint p)
{
   while (p--) {
      ++pos;
      ++yycolumn;
      current = next1;
      next1 = next2;
      next2 = next3;
      next3 = (pos + 3 < length) ? m_code[pos + 3].unicode() : 0;
   }
}

void QScript::Lexer::setDone(State s)
{
   state = s;
   done  = true;
}

int QScript::Lexer::findReservedWord(const QChar *c, int size) const
{
   switch (size) {
      case 2: {
         if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('o')) {
            return QScriptGrammar::T_DO;
         } else if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('f')) {
            return QScriptGrammar::T_IF;
         } else if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n')) {
            return QScriptGrammar::T_IN;
         }
      }
      break;

      case 3: {
         if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('o') && c[2] == QLatin1Char('r')) {
            return QScriptGrammar::T_FOR;
         } else if (c[0] == QLatin1Char('n') && c[1] == QLatin1Char('e') && c[2] == QLatin1Char('w')) {
            return QScriptGrammar::T_NEW;
         } else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('r') && c[2] == QLatin1Char('y')) {
            return QScriptGrammar::T_TRY;
         } else if (c[0] == QLatin1Char('v') && c[1] == QLatin1Char('a') && c[2] == QLatin1Char('r')) {
            return QScriptGrammar::T_VAR;
         } else if (check_reserved) {
            if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n') && c[2] == QLatin1Char('t')) {
               return QScriptGrammar::T_RESERVED_WORD;
            }
         }
      }
      break;

      case 4: {
         if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('a')
               && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('e')) {
            return QScriptGrammar::T_CASE;
         } else if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('l')
                    && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('e')) {
            return QScriptGrammar::T_ELSE;
         } else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('h')
                    && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('s')) {
            return QScriptGrammar::T_THIS;
         } else if (c[0] == QLatin1Char('v') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('d')) {
            return QScriptGrammar::T_VOID;
         } else if (c[0] == QLatin1Char('w') && c[1] == QLatin1Char('i')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('h')) {
            return QScriptGrammar::T_WITH;
         } else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('r')
                    && c[2] == QLatin1Char('u') && c[3] == QLatin1Char('e')) {
            return QScriptGrammar::T_TRUE;
         } else if (c[0] == QLatin1Char('n') && c[1] == QLatin1Char('u')
                    && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('l')) {
            return QScriptGrammar::T_NULL;
         } else if (check_reserved) {
            if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('n')
                  && c[2] == QLatin1Char('u') && c[3] == QLatin1Char('m')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('b') && c[1] == QLatin1Char('y')
                       && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('e')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('l') && c[1] == QLatin1Char('o')
                       && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('g')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('h')
                       && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('r')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('g') && c[1] == QLatin1Char('o')
                       && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('o')) {
               return QScriptGrammar::T_RESERVED_WORD;
            }
         }
      }
      break;

      case 5: {
         if (c[0] == QLatin1Char('b') && c[1] == QLatin1Char('r')
               && c[2] == QLatin1Char('e') && c[3] == QLatin1Char('a')
               && c[4] == QLatin1Char('k')) {
            return QScriptGrammar::T_BREAK;
         } else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('a')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('c')
                    && c[4] == QLatin1Char('h')) {
            return QScriptGrammar::T_CATCH;
         } else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('h')
                    && c[2] == QLatin1Char('r') && c[3] == QLatin1Char('o')
                    && c[4] == QLatin1Char('w')) {
            return QScriptGrammar::T_THROW;
         } else if (c[0] == QLatin1Char('w') && c[1] == QLatin1Char('h')
                    && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('l')
                    && c[4] == QLatin1Char('e')) {
            return QScriptGrammar::T_WHILE;
         } else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('s')
                    && c[4] == QLatin1Char('t')) {
            return QScriptGrammar::T_CONST;
         } else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('a')
                    && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('s')
                    && c[4] == QLatin1Char('e')) {
            return QScriptGrammar::T_FALSE;
         } else if (check_reserved) {
            if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('h')
                  && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('r')
                  && c[4] == QLatin1Char('t')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('u')
                       && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('e')
                       && c[4] == QLatin1Char('r')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('i')
                       && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('a')
                       && c[4] == QLatin1Char('l')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('l')
                       && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('s')
                       && c[4] == QLatin1Char('s')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('l')
                       && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('a')
                       && c[4] == QLatin1Char('t')) {
               return QScriptGrammar::T_RESERVED_WORD;
            }
         }
      }
      break;

      case 6: {
         if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('e')
               && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('e')
               && c[4] == QLatin1Char('t') && c[5] == QLatin1Char('e')) {
            return QScriptGrammar::T_DELETE;
         } else if (c[0] == QLatin1Char('r') && c[1] == QLatin1Char('e')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('u')
                    && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('n')) {
            return QScriptGrammar::T_RETURN;
         } else if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('w')
                    && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('t')
                    && c[4] == QLatin1Char('c') && c[5] == QLatin1Char('h')) {
            return QScriptGrammar::T_SWITCH;
         } else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('y')
                    && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('e')
                    && c[4] == QLatin1Char('o') && c[5] == QLatin1Char('f')) {
            return QScriptGrammar::T_TYPEOF;
         } else if (check_reserved) {
            if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('x')
                  && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('o')
                  && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('t')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('t')
                       && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('t')
                       && c[4] == QLatin1Char('i') && c[5] == QLatin1Char('c')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('o')
                       && c[2] == QLatin1Char('u') && c[3] == QLatin1Char('b')
                       && c[4] == QLatin1Char('l') && c[5] == QLatin1Char('e')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('m')
                       && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('o')
                       && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('t')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('u')
                       && c[2] == QLatin1Char('b') && c[3] == QLatin1Char('l')
                       && c[4] == QLatin1Char('i') && c[5] == QLatin1Char('c')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('n') && c[1] == QLatin1Char('a')
                       && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('i')
                       && c[4] == QLatin1Char('v') && c[5] == QLatin1Char('e')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('h')
                       && c[2] == QLatin1Char('r') && c[3] == QLatin1Char('o')
                       && c[4] == QLatin1Char('w') && c[5] == QLatin1Char('s')) {
               return QScriptGrammar::T_RESERVED_WORD;
            }
         }
      }
      break;

      case 7: {
         if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('e')
               && c[2] == QLatin1Char('f') && c[3] == QLatin1Char('a')
               && c[4] == QLatin1Char('u') && c[5] == QLatin1Char('l')
               && c[6] == QLatin1Char('t')) {
            return QScriptGrammar::T_DEFAULT;
         } else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('i')
                    && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('a')
                    && c[4] == QLatin1Char('l') && c[5] == QLatin1Char('l')
                    && c[6] == QLatin1Char('y')) {
            return QScriptGrammar::T_FINALLY;
         } else if (check_reserved) {
            if (c[0] == QLatin1Char('b') && c[1] == QLatin1Char('o')
                  && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('l')
                  && c[4] == QLatin1Char('e') && c[5] == QLatin1Char('a')
                  && c[6] == QLatin1Char('n')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('x')
                       && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('e')
                       && c[4] == QLatin1Char('n') && c[5] == QLatin1Char('d')
                       && c[6] == QLatin1Char('s')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('a')
                       && c[2] == QLatin1Char('c') && c[3] == QLatin1Char('k')
                       && c[4] == QLatin1Char('a') && c[5] == QLatin1Char('g')
                       && c[6] == QLatin1Char('e')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('r')
                       && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('v')
                       && c[4] == QLatin1Char('a') && c[5] == QLatin1Char('t')
                       && c[6] == QLatin1Char('e')) {
               return QScriptGrammar::T_RESERVED_WORD;
            }
         }
      }
      break;

      case 8: {
         if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('o')
               && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('t')
               && c[4] == QLatin1Char('i') && c[5] == QLatin1Char('n')
               && c[6] == QLatin1Char('u') && c[7] == QLatin1Char('e')) {
            return QScriptGrammar::T_CONTINUE;
         } else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('u')
                    && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('c')
                    && c[4] == QLatin1Char('t') && c[5] == QLatin1Char('i')
                    && c[6] == QLatin1Char('o') && c[7] == QLatin1Char('n')) {
            return QScriptGrammar::T_FUNCTION;
         } else if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('e')
                    && c[2] == QLatin1Char('b') && c[3] == QLatin1Char('u')
                    && c[4] == QLatin1Char('g') && c[5] == QLatin1Char('g')
                    && c[6] == QLatin1Char('e') && c[7] == QLatin1Char('r')) {
            return QScriptGrammar::T_DEBUGGER;
         } else if (check_reserved) {
            if (c[0] == QLatin1Char('a') && c[1] == QLatin1Char('b')
                  && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('t')
                  && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('a')
                  && c[6] == QLatin1Char('c') && c[7] == QLatin1Char('t')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('v') && c[1] == QLatin1Char('o')
                       && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('a')
                       && c[4] == QLatin1Char('t') && c[5] == QLatin1Char('i')
                       && c[6] == QLatin1Char('l') && c[7] == QLatin1Char('e')) {
               return QScriptGrammar::T_RESERVED_WORD;
            }
         }
      }
      break;

      case 9: {
         if (check_reserved) {
            if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n')
                  && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('e')
                  && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('f')
                  && c[6] == QLatin1Char('a') && c[7] == QLatin1Char('c')
                  && c[8] == QLatin1Char('e')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('r')
                       && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('n')
                       && c[4] == QLatin1Char('s') && c[5] == QLatin1Char('i')
                       && c[6] == QLatin1Char('e') && c[7] == QLatin1Char('n')
                       && c[8] == QLatin1Char('t')) {
               return QScriptGrammar::T_RESERVED_WORD;
            } else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('r')
                       && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('t')
                       && c[4] == QLatin1Char('e') && c[5] == QLatin1Char('c')
                       && c[6] == QLatin1Char('t') && c[7] == QLatin1Char('e')
                       && c[8] == QLatin1Char('d')) {
               return QScriptGrammar::T_RESERVED_WORD;
            }
         }
      }
      break;

      case 10: {
         if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n')
               && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('t')
               && c[4] == QLatin1Char('a') && c[5] == QLatin1Char('n')
               && c[6] == QLatin1Char('c') && c[7] == QLatin1Char('e')
               && c[8] == QLatin1Char('o') && c[9] == QLatin1Char('f')) {
            return QScriptGrammar::T_INSTANCEOF;
         } else if (check_reserved) {
            if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('m')
                  && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('l')
                  && c[4] == QLatin1Char('e') && c[5] == QLatin1Char('m')
                  && c[6] == QLatin1Char('e') && c[7] == QLatin1Char('n')
                  && c[8] == QLatin1Char('t') && c[9] == QLatin1Char('s')) {
               return QScriptGrammar::T_RESERVED_WORD;
            }
         }
      }
      break;

      case 12: {
         if (check_reserved) {
            if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('y')
                  && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('c')
                  && c[4] == QLatin1Char('h') && c[5] == QLatin1Char('r')
                  && c[6] == QLatin1Char('o') && c[7] == QLatin1Char('n')
                  && c[8] == QLatin1Char('i') && c[9] == QLatin1Char('z')
                  && c[10] == QLatin1Char('e') && c[11] == QLatin1Char('d')) {
               return QScriptGrammar::T_RESERVED_WORD;
            }
         }
      }
      break;

   } // switch

   return -1;
}

int QScript::Lexer::lex()
{
   int token = 0;
   state = Start;
   ushort stringType = 0; // either single or double quotes
   pos8 = pos16 = 0;
   done = false;
   terminator = false;

   // did we push a token on the stack previously ?
   // (after an automatic semicolon insertion)
   if (stackToken >= 0) {
      setDone(Other);
      token = stackToken;
      stackToken = -1;
   }

   while (!done) {
      switch (state) {
         case Start:
            if (isWhiteSpace()) {
               // do nothing
            } else if (current == '/' && next1 == '/') {
               recordStartPos();
               shift(1);
               Q_ASSERT(pos16 == 0);
               state = InSingleLineComment;
            } else if (current == '/' && next1 == '*') {
               recordStartPos();
               shift(1);
               Q_ASSERT(pos16 == 0);
               state = InMultiLineComment;
            } else if (current == 0) {
               syncProhibitAutomaticSemicolon();
               if (!terminator && !delimited && !prohibitAutomaticSemicolon) {
                  // automatic semicolon insertion if program incomplete
                  token = QScriptGrammar::T_SEMICOLON;
                  stackToken = 0;
                  setDone(Other);
               } else {
                  setDone(Eof);
               }
            } else if (isLineTerminator()) {
               shiftWindowsLineBreak();
               yylineno++;
               yycolumn = 0;
               bol = true;
               terminator = true;
               syncProhibitAutomaticSemicolon();
               if (restrKeyword) {
                  token = QScriptGrammar::T_SEMICOLON;
                  setDone(Other);
               }
            } else if (current == '"' || current == '\'') {
               recordStartPos();
               state = InString;
               stringType = current;
            } else if (isIdentLetter(current)) {
               recordStartPos();
               record16(current);
               state = InIdentifier;
            } else if (current == '0') {
               recordStartPos();
               record8(current);
               state = InNum0;
            } else if (isDecimalDigit(current)) {
               recordStartPos();
               record8(current);
               state = InNum;
            } else if (current == '.' && isDecimalDigit(next1)) {
               recordStartPos();
               record8(current);
               state = InDecimal;
            } else {
               recordStartPos();
               token = matchPunctuator(current, next1, next2, next3);
               if (token != -1) {
                  if (terminator && !delimited && !prohibitAutomaticSemicolon
                        && (token == QScriptGrammar::T_PLUS_PLUS
                            || token == QScriptGrammar::T_MINUS_MINUS)) {
                     // automatic semicolon insertion
                     stackToken = token;
                     token = QScriptGrammar::T_SEMICOLON;
                  }
                  setDone(Other);
               } else {
                  setDone(Bad);
                  err = IllegalCharacter;
                  errmsg = LU::tr("Illegal character");
               }
            }
            break;
         case InString:
            if (current == stringType) {
               shift(1);
               setDone(String);
            } else if (current == 0 || isLineTerminator()) {
               setDone(Bad);
               err = UnclosedStringLiteral;
               errmsg = LU::tr("Unclosed string at end of line");
            } else if (current == '\\') {
               state = InEscapeSequence;
            } else {
               record16(current);
            }
            break;
         // Escape Sequences inside of strings
         case InEscapeSequence:
            if (isOctalDigit(current)) {
               if (current >= '0' && current <= '3' &&
                     isOctalDigit(next1) && isOctalDigit(next2)) {
                  record16(convertOctal(current, next1, next2));
                  shift(2);
                  state = InString;
               } else if (isOctalDigit(current) &&
                          isOctalDigit(next1)) {
                  record16(convertOctal('0', current, next1));
                  shift(1);
                  state = InString;
               } else if (isOctalDigit(current)) {
                  record16(convertOctal('0', '0', current));
                  state = InString;
               } else {
                  setDone(Bad);
                  err = IllegalEscapeSequence;
                  errmsg = LU::tr("Illegal escape sequence");
               }
            } else if (current == 'x') {
               state = InHexEscape;
            } else if (current == 'u') {
               state = InUnicodeEscape;
            } else {
               record16(singleEscape(current));
               state = InString;
            }
            break;
         case InHexEscape:
            if (isHexDigit(current) && isHexDigit(next1)) {
               state = InString;
               record16(QLatin1Char(convertHex(current, next1)));
               shift(1);
            } else if (current == stringType) {
               record16(QLatin1Char('x'));
               shift(1);
               setDone(String);
            } else {
               record16(QLatin1Char('x'));
               record16(current);
               state = InString;
            }
            break;
         case InUnicodeEscape:
            if (isHexDigit(current) && isHexDigit(next1) &&
                  isHexDigit(next2) && isHexDigit(next3)) {
               record16(convertUnicode(current, next1, next2, next3));
               shift(3);
               state = InString;
            } else if (current == stringType) {
               record16(QLatin1Char('u'));
               shift(1);
               setDone(String);
            } else {
               setDone(Bad);
               err = IllegalUnicodeEscapeSequence;
               errmsg = LU::tr("Illegal unicode escape sequence");
            }
            break;
         case InSingleLineComment:
            if (isLineTerminator()) {
               record16(current); // include newline
               processComment(buffer16, pos16);
               shiftWindowsLineBreak();
               yylineno++;
               yycolumn = 0;
               pos16 = 0;
               terminator = true;
               bol = true;
               if (restrKeyword) {
                  token = QScriptGrammar::T_SEMICOLON;
                  setDone(Other);
               } else {
                  state = Start;
               }
            } else if (current == 0) {
               setDone(Eof);
            } else {
               record16(current);
            }
            break;
         case InMultiLineComment:
            if (current == 0) {
               setDone(Bad);
               err = UnclosedComment;
               errmsg = LU::tr("Unclosed comment at end of file");
            } else if (isLineTerminator()) {
               shiftWindowsLineBreak();
               yylineno++;
            } else if (current == '*' && next1 == '/') {
               processComment(buffer16, pos16);
               pos16 = 0;
               state = Start;
               shift(1);
            } else {
               record16(current);
            }
            break;
         case InIdentifier:
            if (isIdentLetter(current) || isDecimalDigit(current)) {
               record16(current);
               break;
            }
            setDone(Identifier);
            break;
         case InNum0:
            if (current == 'x' || current == 'X') {
               record8(current);
               state = InHex;
            } else if (current == '.') {
               record8(current);
               state = InDecimal;
            } else if (current == 'e' || current == 'E') {
               record8(current);
               state = InExponentIndicator;
            } else if (isOctalDigit(current)) {
               record8(current);
               state = InOctal;
            } else if (isDecimalDigit(current)) {
               record8(current);
               state = InDecimal;
            } else {
               setDone(Number);
            }
            break;
         case InHex:
            if (isHexDigit(current)) {
               record8(current);
            } else {
               setDone(Hex);
            }
            break;
         case InOctal:
            if (isOctalDigit(current)) {
               record8(current);
            } else if (isDecimalDigit(current)) {
               record8(current);
               state = InDecimal;
            } else {
               setDone(Octal);
            }
            break;
         case InNum:
            if (isDecimalDigit(current)) {
               record8(current);
            } else if (current == '.') {
               record8(current);
               state = InDecimal;
            } else if (current == 'e' || current == 'E') {
               record8(current);
               state = InExponentIndicator;
            } else {
               setDone(Number);
            }
            break;
         case InDecimal:
            if (isDecimalDigit(current)) {
               record8(current);
            } else if (current == 'e' || current == 'E') {
               record8(current);
               state = InExponentIndicator;
            } else {
               setDone(Number);
            }
            break;
         case InExponentIndicator:
            if (current == '+' || current == '-') {
               record8(current);
            } else if (isDecimalDigit(current)) {
               record8(current);
               state = InExponent;
            } else {
               setDone(Bad);
               err = IllegalExponentIndicator;
               errmsg = LU::tr("Illegal syntax for exponential number");
            }
            break;
         case InExponent:
            if (isDecimalDigit(current)) {
               record8(current);
            } else {
               setDone(Number);
            }
            break;
         default:
            Q_ASSERT_X(0, "Lexer::lex", "Unhandled state in switch statement");
      }

      // move on to the next character
      if (!done) {
         shift(1);
      }
      if (state != Start && state != InSingleLineComment) {
         bol = false;
      }
   }

   // no identifiers allowed directly after numeric literal, e.g. "3in" is bad
   if ((state == Number || state == Octal || state == Hex)
         && isIdentLetter(current)) {
      state = Bad;
      err = IllegalIdentifier;
      errmsg = LU::tr("Identifier cannot start with numeric literal");
   }

   // terminate string
   buffer8[pos8] = '\0';

   double dval = 0;
   if (state == Number) {
      dval = qstrtod(buffer8, 0, 0);
   } else if (state == Hex) { // scan hex numbers
      dval = QScript::integerFromString(buffer8, pos8, 16);
      state = Number;
   } else if (state == Octal) {   // scan octal number
      dval = QScript::integerFromString(buffer8, pos8, 8);
      state = Number;
   }

   restrKeyword = false;
   delimited = false;

   switch (parenthesesState) {
      case IgnoreParentheses:
         break;
      case CountParentheses:
         if (token == QScriptGrammar::T_RPAREN) {
            --parenthesesCount;
            if (parenthesesCount == 0) {
               parenthesesState = BalancedParentheses;
            }
         } else if (token == QScriptGrammar::T_LPAREN) {
            ++parenthesesCount;
         }
         break;
      case BalancedParentheses:
         parenthesesState = IgnoreParentheses;
         break;
   }

   switch (state) {
      case Eof:
         return 0;
      case Other:
         if (token == QScriptGrammar::T_RBRACE || token == QScriptGrammar::T_SEMICOLON) {
            delimited = true;
         }
         return token;
      case Identifier:
         if ((token = findReservedWord(buffer16, pos16)) < 0) {
            /* TODO: close leak on parse error. same holds true for String */
            qsyylval = QString(buffer16, pos16);
            return QScriptGrammar::T_IDENTIFIER;
         }
         if (token == QScriptGrammar::T_CONTINUE || token == QScriptGrammar::T_BREAK
               || token == QScriptGrammar::T_RETURN || token == QScriptGrammar::T_THROW) {
            restrKeyword = true;
         } else if (token == QScriptGrammar::T_IF || token == QScriptGrammar::T_FOR
                    || token == QScriptGrammar::T_WHILE || token == QScriptGrammar::T_WITH) {
            parenthesesState = CountParentheses;
            parenthesesCount = 0;
         } else if (token == QScriptGrammar::T_DO) {
            parenthesesState = BalancedParentheses;
         }
         return token;
      case String:
         qsyylval = QString(buffer16, pos16);
         return QScriptGrammar::T_STRING_LITERAL;
      case Number:
         qsyylval = dval;
         return QScriptGrammar::T_NUMERIC_LITERAL;
      case Bad:
         return -1;
      default:
         Q_ASSERT(!"unhandled numeration value in switch");
         return -1;
   }
}

bool QScript::Lexer::isWhiteSpace() const
{
   return (current == ' ' || current == '\t' ||
           current == 0x0b || current == 0x0c);
}

bool QScript::Lexer::isLineTerminator() const
{
   return (current == '\n' || current == '\r');
}

bool QScript::Lexer::isIdentLetter(ushort c)
{
   /* TODO: allow other legitimate unicode chars */
   return ((c >= 'a' && c <= 'z')
           || (c >= 'A' && c <= 'Z')
           || c == '$'
           || c == '_');
}

bool QScript::Lexer::isDecimalDigit(ushort c)
{
   return (c >= '0' && c <= '9');
}

bool QScript::Lexer::isHexDigit(ushort c) const
{
   return ((c >= '0' && c <= '9')
           || (c >= 'a' && c <= 'f')
           || (c >= 'A' && c <= 'F'));
}

bool QScript::Lexer::isOctalDigit(ushort c) const
{
   return (c >= '0' && c <= '7');
}

int QScript::Lexer::matchPunctuator(ushort c1, ushort c2,
                                    ushort c3, ushort c4)
{
   if (c1 == '>' && c2 == '>' && c3 == '>' && c4 == '=') {
      shift(4);
      return QScriptGrammar::T_GT_GT_GT_EQ;
   } else if (c1 == '=' && c2 == '=' && c3 == '=') {
      shift(3);
      return QScriptGrammar::T_EQ_EQ_EQ;
   } else if (c1 == '!' && c2 == '=' && c3 == '=') {
      shift(3);
      return QScriptGrammar::T_NOT_EQ_EQ;
   } else if (c1 == '>' && c2 == '>' && c3 == '>') {
      shift(3);
      return QScriptGrammar::T_GT_GT_GT;
   } else if (c1 == '<' && c2 == '<' && c3 == '=') {
      shift(3);
      return QScriptGrammar::T_LT_LT_EQ;
   } else if (c1 == '>' && c2 == '>' && c3 == '=') {
      shift(3);
      return QScriptGrammar::T_GT_GT_EQ;
   } else if (c1 == '<' && c2 == '=') {
      shift(2);
      return QScriptGrammar::T_LE;
   } else if (c1 == '>' && c2 == '=') {
      shift(2);
      return QScriptGrammar::T_GE;
   } else if (c1 == '!' && c2 == '=') {
      shift(2);
      return QScriptGrammar::T_NOT_EQ;
   } else if (c1 == '+' && c2 == '+') {
      shift(2);
      return QScriptGrammar::T_PLUS_PLUS;
   } else if (c1 == '-' && c2 == '-') {
      shift(2);
      return QScriptGrammar::T_MINUS_MINUS;
   } else if (c1 == '=' && c2 == '=') {
      shift(2);
      return QScriptGrammar::T_EQ_EQ;
   } else if (c1 == '+' && c2 == '=') {
      shift(2);
      return QScriptGrammar::T_PLUS_EQ;
   } else if (c1 == '-' && c2 == '=') {
      shift(2);
      return QScriptGrammar::T_MINUS_EQ;
   } else if (c1 == '*' && c2 == '=') {
      shift(2);
      return QScriptGrammar::T_STAR_EQ;
   } else if (c1 == '/' && c2 == '=') {
      shift(2);
      return QScriptGrammar::T_DIVIDE_EQ;
   } else if (c1 == '&' && c2 == '=') {
      shift(2);
      return QScriptGrammar::T_AND_EQ;
   } else if (c1 == '^' && c2 == '=') {
      shift(2);
      return QScriptGrammar::T_XOR_EQ;
   } else if (c1 == '%' && c2 == '=') {
      shift(2);
      return QScriptGrammar::T_REMAINDER_EQ;
   } else if (c1 == '|' && c2 == '=') {
      shift(2);
      return QScriptGrammar::T_OR_EQ;
   } else if (c1 == '<' && c2 == '<') {
      shift(2);
      return QScriptGrammar::T_LT_LT;
   } else if (c1 == '>' && c2 == '>') {
      shift(2);
      return QScriptGrammar::T_GT_GT;
   } else if (c1 == '&' && c2 == '&') {
      shift(2);
      return QScriptGrammar::T_AND_AND;
   } else if (c1 == '|' && c2 == '|') {
      shift(2);
      return QScriptGrammar::T_OR_OR;
   }

   switch (c1) {
      case '=':
         shift(1);
         return QScriptGrammar::T_EQ;
      case '>':
         shift(1);
         return QScriptGrammar::T_GT;
      case '<':
         shift(1);
         return QScriptGrammar::T_LT;
      case ',':
         shift(1);
         return QScriptGrammar::T_COMMA;
      case '!':
         shift(1);
         return QScriptGrammar::T_NOT;
      case '~':
         shift(1);
         return QScriptGrammar::T_TILDE;
      case '?':
         shift(1);
         return QScriptGrammar::T_QUESTION;
      case ':':
         shift(1);
         return QScriptGrammar::T_COLON;
      case '.':
         shift(1);
         return QScriptGrammar::T_DOT;
      case '+':
         shift(1);
         return QScriptGrammar::T_PLUS;
      case '-':
         shift(1);
         return QScriptGrammar::T_MINUS;
      case '*':
         shift(1);
         return QScriptGrammar::T_STAR;
      case '/':
         shift(1);
         return QScriptGrammar::T_DIVIDE_;
      case '&':
         shift(1);
         return QScriptGrammar::T_AND;
      case '|':
         shift(1);
         return QScriptGrammar::T_OR;
      case '^':
         shift(1);
         return QScriptGrammar::T_XOR;
      case '%':
         shift(1);
         return QScriptGrammar::T_REMAINDER;
      case '(':
         shift(1);
         return QScriptGrammar::T_LPAREN;
      case ')':
         shift(1);
         return QScriptGrammar::T_RPAREN;
      case '{':
         shift(1);
         return QScriptGrammar::T_LBRACE;
      case '}':
         shift(1);
         return QScriptGrammar::T_RBRACE;
      case '[':
         shift(1);
         return QScriptGrammar::T_LBRACKET;
      case ']':
         shift(1);
         return QScriptGrammar::T_RBRACKET;
      case ';':
         shift(1);
         return QScriptGrammar::T_SEMICOLON;

      default:
         return -1;
   }
}

ushort QScript::Lexer::singleEscape(ushort c) const
{
   switch (c) {
      case 'b':
         return 0x08;
      case 't':
         return 0x09;
      case 'n':
         return 0x0A;
      case 'v':
         return 0x0B;
      case 'f':
         return 0x0C;
      case 'r':
         return 0x0D;
      case '"':
         return 0x22;
      case '\'':
         return 0x27;
      case '\\':
         return 0x5C;
      default:
         return c;
   }
}

ushort QScript::Lexer::convertOctal(ushort c1, ushort c2, ushort c3) const
{
   return ((c1 - '0') * 64 + (c2 - '0') * 8 + c3 - '0');
}

unsigned char QScript::Lexer::convertHex(ushort c)
{
   if (c >= '0' && c <= '9') {
      return (c - '0');
   } else if (c >= 'a' && c <= 'f') {
      return (c - 'a' + 10);
   } else {
      return (c - 'A' + 10);
   }
}

unsigned char QScript::Lexer::convertHex(char32_t c1, char32_t c2)
{
   return ((convertHex(c1) << 4) + convertHex(c2));
}

QChar QScript::Lexer::convertUnicode(char32_t c1, char32_t c2, char32_t c3, char32_t c4)
{
   return QChar(char32_t((convertHex(c1) << 12) + (convertHex(c2) << 8) + (convertHex(c3) << 4) + convertHex(c4)));
}

void QScript::Lexer::record8(ushort c)
{
   Q_ASSERT(c <= 0xff);

   // enlarge buffer if full
   if (pos8 >= size8 - 1) {
      char *tmp = new char[2 * size8];
      memcpy(tmp, buffer8, size8 * sizeof(char));
      delete [] buffer8;
      buffer8 = tmp;
      size8 *= 2;
   }

   buffer8[pos8++] = (char) c;
}

void QScript::Lexer::record16(QChar c)
{
   // enlarge buffer if full
   if (pos16 >= size16 - 1) {
      QChar *tmp = new QChar[2 * size16];
      memcpy(tmp, buffer16, size16 * sizeof(QChar));
      delete [] buffer16;
      buffer16 = tmp;
      size16 *= 2;
   }

   buffer16[pos16++] = c;
}

void QScript::Lexer::recordStartPos()
{
   startlineno = yylineno;
   startcolumn = yycolumn;
}

bool QScript::Lexer::scanRegExp(RegExpBodyPrefix prefix)
{
   pos16 = 0;
   bool lastWasEscape = false;

   if (prefix == EqualPrefix) {
      record16(QLatin1Char('='));
   }

   while (1) {
      if (isLineTerminator() || current == 0) {
         errmsg = LU::tr("Unterminated regular expression literal");
         return false;
      } else if (current != '/' || lastWasEscape == true) {
         record16(current);
         lastWasEscape = !lastWasEscape && (current == '\\');
      } else {
         pattern = QString(buffer16, pos16);
         pos16 = 0;
         shift(1);
         break;
      }
      shift(1);
   }

   flags = 0;
   while (isIdentLetter(current)) {
      record16(current);
      shift(1);
   }

   return true;
}

void QScript::Lexer::syncProhibitAutomaticSemicolon()
{
   if (parenthesesState == BalancedParentheses) {
      // we have seen something like "if (foo)", which means we should
      // never insert an automatic semicolon at this point, since it would
      // then be expanded into an empty statement (ECMA-262 7.9.1)
      prohibitAutomaticSemicolon = true;
      parenthesesState = IgnoreParentheses;
   } else {
      prohibitAutomaticSemicolon = false;
   }
}

void QScript::Lexer::processComment(const QChar *chars, int length)
{
   commentProcessor->processComment(chars, length);
}


class Translator;

class QScriptParser: protected QScriptGrammar, public QScript::CommentProcessor
{
 public:
   QVariant val;

   struct Location {
      int startLine;
      int startColumn;
      int endLine;
      int endColumn;
   };

 public:
   QScriptParser();
   ~QScriptParser();

   void setLexer(QScript::Lexer *);
   void setTranslator(Translator *);

   bool parse();

   QString fileName() const {
      return lexer->fileName();
   }
   inline QString errorMessage() const {
      return error_message;
   }
   inline int errorLineNumber() const {
      return error_lineno;
   }
   inline int errorColumnNumber() const {
      return error_column;
   }

 protected:
   inline void reallocateStack();

   inline QVariant &sym(int index) {
      return sym_stack [tos + index - 1];
   }

   inline Location &loc(int index) {
      return location_stack [tos + index - 2];
   }

   std::ostream &yyMsg(int line = 0);

   virtual void processComment(const QChar *, int);

 protected:
   int tos;
   int stack_size;
   QVector<QVariant> sym_stack;
   int *state_stack;
   Location *location_stack;
   QString error_message;
   int error_lineno;
   int error_column;

 private:
   QScript::Lexer *lexer;
   Translator *translator;
   QString trcontext;
   QString extracomment;
   QString msgid;
   QString sourcetext;
   TranslatorMessage::ExtraData extra;
};

inline void QScriptParser::reallocateStack()
{
   if (! stack_size) {
      stack_size = 128;
   } else {
      stack_size <<= 1;
   }

   sym_stack.resize(stack_size);
   state_stack = reinterpret_cast<int *> (qRealloc(state_stack, stack_size * sizeof(int)));
   location_stack = reinterpret_cast<Location *> (qRealloc(location_stack, stack_size * sizeof(Location)));
}

inline static bool automatic(QScript::Lexer *lexer, int token)
{
   return (token == QScriptGrammar::T_RBRACE)
          || (token == 0)
          || lexer->prevTerminator();
}

QScriptParser::QScriptParser():
   tos(0),
   stack_size(0),
   sym_stack(0),
   state_stack(0),
   location_stack(0),
   lexer(0),
   translator(0)
{
}

QScriptParser::~QScriptParser()
{
   if (stack_size) {
      qFree(state_stack);
      qFree(location_stack);
   }
}

static inline QScriptParser::Location location(QScript::Lexer *lexer)
{
   QScriptParser::Location loc;
   loc.startLine = lexer->startLineNo();
   loc.startColumn = lexer->startColumnNo();
   loc.endLine = lexer->endLineNo();
   loc.endColumn = lexer->endColumnNo();
   return loc;
}

void QScriptParser::setLexer(QScript::Lexer *lex)
{
   lexer = lex;
}

void QScriptParser::setTranslator(Translator *tor)
{
   translator = tor;
}

bool QScriptParser::parse()
{
   Q_ASSERT(lexer != 0);
   Q_ASSERT(translator != 0);
   trcontext = QFileInfo(fileName()).baseName();

   const int INITIAL_STATE = 0;

   int yytoken = -1;
   int saved_yytoken = -1;
   int identLineNo = -1;

   reallocateStack();

   tos = 0;
   state_stack[++tos] = INITIAL_STATE;

   while (true) {
      const int state = state_stack [tos];
      if (yytoken == -1 && - TERMINAL_COUNT != action_index [state]) {
         if (saved_yytoken == -1) {
            yytoken = lexer->lex();
            location_stack [tos] = location(lexer);
         } else {
            yytoken = saved_yytoken;
            saved_yytoken = -1;
         }
      }

      int act = t_action (state, yytoken);

      if (act == ACCEPT_STATE) {
         return true;
      }

      else if (act > 0) {
         if (++tos == stack_size) {
            reallocateStack();
         }

         sym_stack [tos] = lexer->val ();
         state_stack [tos] = act;
         location_stack [tos] = location(lexer);
         yytoken = -1;
      }

      else if (act < 0) {
         int r = - act - 1;

         tos -= rhs [r];
         act = state_stack [tos++];

         switch (r) {

            case 1: {
               sym(1) = sym(1).toByteArray();
               identLineNo = lexer->startLineNo();
            }
            break;

            case 7: {
               bool rx = lexer->scanRegExp(QScript::Lexer::NoPrefix);
               if (!rx) {
                  error_message = lexer->errorMessage();
                  error_lineno = lexer->startLineNo();
                  error_column = lexer->startColumnNo();
                  return false;
               }
            }
            break;

            case 8: {
               bool rx = lexer->scanRegExp(QScript::Lexer::EqualPrefix);
               if (!rx) {
                  error_message = lexer->errorMessage();
                  error_lineno = lexer->startLineNo();
                  error_column = lexer->startColumnNo();
                  return false;
               }
            }
            break;

            case 66: {
               QString name = sym(1).toString();

               if ((name == QLatin1String("qsTranslate")) || (name == "QT_TRANSLATE_NOOP")) {
                  if (!sourcetext.isEmpty()) {
                     yyMsg(identLineNo) << qPrintable(LU::tr("//% cannot be used with %1(). Ignoring\n").formatArg(name));
                  }

                  QVariantList args = sym(2).toList();
                  if (args.size() < 2) {
                     yyMsg(identLineNo) << qPrintable(LU::tr("%1() requires at least two arguments.\n").formatArg(name));

                  } else {
                     if ((args.at(0).type() != QVariant::String)
                           || (args.at(1).type() != QVariant::String)) {
                        yyMsg(identLineNo) << qPrintable(LU::tr("%1(): both arguments must be literal strings.\n").formatArg(name));
                     } else {
                        QString context = args.at(0).toString();
                        QString text = args.at(1).toString();
                        QString comment = args.value(2).toString();
                        bool plural = (args.size() > 4);
                        recordMessage(translator, context, text, comment, extracomment,
                                      msgid, extra, plural, fileName(), identLineNo);
                     }
                  }
                  sourcetext.clear();
                  extracomment.clear();
                  msgid.clear();
                  extra.clear();
               } else if ((name == QLatin1String("qsTr")) || (name == QLatin1String("QT_TR_NOOP"))) {
                  if (!sourcetext.isEmpty()) {
                     yyMsg(identLineNo) << qPrintable(LU::tr("//% cannot be used with %1(). Ignoring\n").formatArg(name));
                  }
                  QVariantList args = sym(2).toList();
                  if (args.size() < 1) {
                     yyMsg(identLineNo) << qPrintable(LU::tr("%1() requires at least one argument.\n").formatArg(name));
                  } else {
                     if (args.at(0).type() != QVariant::String) {
                        yyMsg(identLineNo) << qPrintable(LU::tr("%1(): text to translate must be a literal string.\n").formatArg(name));
                     } else {
                        QString text = args.at(0).toString();
                        QString comment = args.value(1).toString();
                        bool plural = (args.size() > 2);
                        recordMessage(translator, trcontext, text, comment, extracomment,
                                      msgid, extra, plural, fileName(), identLineNo);
                     }
                  }
                  sourcetext.clear();
                  extracomment.clear();
                  msgid.clear();
                  extra.clear();
               } else if ((name == QLatin1String("qsTrId")) || (name == QLatin1String("QT_TRID_NOOP"))) {
                  if (!msgid.isEmpty()) {
                     yyMsg(identLineNo) << qPrintable(LU::tr("//= cannot be used with %1(). Ignoring\n").formatArg(name));
                  }
                  QVariantList args = sym(2).toList();
                  if (args.size() < 1) {
                     yyMsg(identLineNo) << qPrintable(LU::tr("%1() requires at least one argument.\n").formatArg(name));
                  } else {
                     if (args.at(0).type() != QVariant::String) {
                        yyMsg(identLineNo) << qPrintable(LU::tr("%1(): identifier must be a literal string.\n").formatArg(name));
                     } else {
                        msgid = args.at(0).toString();
                        bool plural = (args.size() > 1);
                        recordMessage(translator, QString(), sourcetext, QString(), extracomment,
                                      msgid, extra, plural, fileName(), identLineNo);
                     }
                  }
                  sourcetext.clear();
                  extracomment.clear();
                  msgid.clear();
                  extra.clear();
               }
            }
            break;

            case 70: {
               sym(1) = QVariantList();
            }
            break;

            case 71: {
               sym(1) = sym(2);
            }
            break;

            case 72: {
               sym(1) = QVariantList() << sym(1);
            }
            break;

            case 73: {
               sym(1) = sym(1).toList() << sym(3);
            }
            break;

            case 94: {
               if ((sym(1).type() == QVariant::String) || (sym(3).type() == QVariant::String)) {
                  sym(1) = sym(1).toString() + sym(3).toString();
               } else {
                  sym(1) = QVariant();
               }
            }
            break;

            case 171:

            case 172:

            case 173:

            case 174:

            case 175:

            case 176:

            case 177:

            case 178:

            case 179:

            case 180:

            case 181:

            case 182:

            case 183:

            case 184:

            case 185:
               if (!sourcetext.isEmpty() || !extracomment.isEmpty() || !msgid.isEmpty() || !extra.isEmpty()) {
                  yyMsg() << qPrintable(LU::tr("Discarding unconsumed meta data\n"));
                  sourcetext.clear();
                  extracomment.clear();
                  msgid.clear();
                  extra.clear();
               }
               break;

         } // switch

         state_stack [tos] = nt_action (act, lhs [r] - TERMINAL_COUNT);

         if (rhs[r] > 1) {
            location_stack[tos - 1].endLine = location_stack[tos + rhs[r] - 2].endLine;
            location_stack[tos - 1].endColumn = location_stack[tos + rhs[r] - 2].endColumn;
            location_stack[tos] = location_stack[tos + rhs[r] - 1];
         }
      }

      else {
         if (saved_yytoken == -1 && automatic (lexer, yytoken) && t_action (state, T_AUTOMATIC_SEMICOLON) > 0) {
            saved_yytoken = yytoken;
            yytoken = T_SEMICOLON;
            continue;
         }

         else if ((state == INITIAL_STATE) && (yytoken == 0)) {
            // accept empty input
            yytoken = T_SEMICOLON;
            continue;
         }

         int ers = state;
         int shifts = 0;
         int reduces = 0;
         int expected_tokens [3];
         for (int tk = 0; tk < TERMINAL_COUNT; ++tk) {
            int k = t_action (ers, tk);

            if (! k) {
               continue;
            } else if (k < 0) {
               ++reduces;
            } else if (spell [tk]) {
               if (shifts < 3) {
                  expected_tokens [shifts] = tk;
               }
               ++shifts;
            }
         }

         error_message.clear ();
         if (shifts && shifts < 3) {
            bool first = true;

            for (int s = 0; s < shifts; ++s) {
               if (first)
                  //: Beginning of the string that contains
                  //: comma-separated list of expected tokens
               {
                  error_message += LU::tr("Expected ");
               } else {
                  error_message += QLatin1String (", ");
               }

               first = false;
               error_message += QLatin1String("`");
               error_message += QString::fromLatin1(spell [expected_tokens [s]]);
               error_message += QLatin1String("'");
            }
         }

         if (error_message.isEmpty()) {
            error_message = lexer->errorMessage();
         }

         error_lineno = lexer->startLineNo();
         error_column = lexer->startColumnNo();

         return false;
      }
   }

   return false;
}

std::ostream &QScriptParser::yyMsg(int line)
{
   return std::cerr << qPrintable(fileName()) << ':' << (line ? line : lexer->startLineNo()) << ": ";
}

void QScriptParser::processComment(const QChar *chars, int length)
{
   if (!length) {
      return;
   }

   // Try to match the logic of the C++ parser.
   if (*chars == QLatin1Char(':') && chars[1].isSpace()) {
      extracomment += QString(chars + 2, length - 2);

   } else if (*chars == QLatin1Char('=') && chars[1].isSpace()) {
      msgid = QString(chars + 2, length - 2).simplified();

   } else if (*chars == QLatin1Char('~') && chars[1].isSpace()) {
      QString text = QString(chars + 2, length - 2).trimmed();
      int k = text.indexOf(QLatin1Char(' '));
      if (k > -1) {
         extra.insert(text.left(k), text.mid(k + 1).trimmed());
      }

   } else if (*chars == QLatin1Char('%') && chars[1].isSpace()) {
      ushort *ptr = (ushort *)sourcetext.data() + sourcetext.length();
      int p = 2, c;

      forever {
         if (p >= length)
         {
            break;
         }
         c = chars[p++].unicode();
         if (isspace(c))
         {
            continue;
         }
         if (c != '"')
         {
            yyMsg() << qPrintable(LU::tr("Unexpected character in meta string\n"));
            break;
         }
         forever {
            if (p >= length)
            {
            whoops:
               yyMsg() << qPrintable(LU::tr("Unterminated meta string\n"));
               break;
            }
            c = chars[p++].unicode();
            if (c == '"')
            {
               break;
            }
            if (c == '\\')
            {
               if (p >= length) {
                  goto whoops;
               }
               c = chars[p++].unicode();
               if (c == '\n') {
                  goto whoops;
               }
               *ptr++ = '\\';
            }
            *ptr++ = c;
         }
      }

      sourcetext.resize(ptr - (ushort *)sourcetext.data());

   } else {
      int idx = 0;
      ushort c;

      while ((c = chars[idx].unicode()) == ' ' || c == '\t' || c == '\n') {
         ++idx;
      }

      if (! memcmp(chars + idx, MagicComment.constData(), MagicComment.size_storage() * 2)) {
         idx += MagicComment.size_storage();

         QString comment = QString(chars + idx, length - idx).simplified();
         int k = comment.indexOf(QLatin1Char(' '));

         if (k == -1) {
            trcontext = comment;

         } else {
            trcontext = comment.left(k);
            comment.remove(0, k + 1);

            TranslatorMessage msg(trcontext, QString(),comment, QString(), fileName(), lexer->startLineNo(), QStringList(),
                  TranslatorMessage::Finished, /*plural=*/false);

            msg.setExtraComment(extracomment.simplified());
            extracomment.clear();
            translator->append(msg);
            translator->setExtras(extra);
            extra.clear();
         }
      }
   }
}


bool loadQScript(Translator &translator, const QString &filename, ConversionData &cd)
{
   QFile file(filename);

   if (! file.open(QIODevice::ReadOnly)) {
      cd.appendError(LU::tr("Can not open %1: %2").formatArgs(filename, file.errorString()));
      return false;
   }

   QTextStream ts(&file);
   QByteArray codecName;

   if (!cd.m_codecForSource.isEmpty()) {
      codecName = cd.m_codecForSource;
   } else {
      codecName = translator.codecName();   // Just because it should be latin1 already
   }

   ts.setCodec(QTextCodec::codecForName(codecName));
   ts.setAutoDetectUnicode(true);

   QString code = ts.readAll();
   QScriptParser parser;
   QScript::Lexer lexer(&parser);
   lexer.setCode(code, filename, /*lineNumber=*/1);
   parser.setLexer(&lexer);
   parser.setTranslator(&translator);
   if (!parser.parse()) {
      std::cerr << qPrintable(filename) << ':' << parser.errorLineNumber() << ": "
                << qPrintable(parser.errorMessage()) << std::endl;
      return false;
   }

   // Java uses UTF-16 internally and Jambi makes UTF-8 for tr() purposes of it.
   translator.setCodecName("UTF-8");
   return true;
}

QT_END_NAMESPACE
